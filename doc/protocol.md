## Проткол обмена ##

TODO формат сообщений свой tgbf

взаимодествие client-client и client-server делятся на две категории,
 * одиночные сообщения, посылаются в тех случах когда передаваемые данные помещаются в один пакет (возможно в несколько,
     но не больше чем требуется для настройки потока)
 * сообщения потока - цепочки сообщений в которых важна последовательность и надежность доставки, применятся для
     больших объемов данных (возможно медиапотоков)

## типы сообщений ##

* `BASE`        базовая часть сообщений, содержит:
    * `id(T02)`:  циклический идентификатор (используется для фильтрации дублей, уникален для каждого src)
    * `scr(T16)`: отпечаток CPubK клиента отправителя
    * `dst(T16)`: отпечаток CPubK клиента адресата
* `MSG`     extends `BASE`     единичные сообщения шифрованные CPubK адресата
    * `sign(TB)`: подпись СPrK отправителя
    * `cipher(TH)`: тип кодирования данных: `MSG_CIPHER_NONE = 0` (используется во время CA), `MSG_CIPHER_DST_PUBK = 1`
    * `data(TB)`: зашифрованные CRrK данные, содержат одну из указанных ниже структур
* `STR`    заголовок потока с данными  (подписан CPrK)
    * `streamId(T02)`: идентификатор потока
    * `id(T??)`: последовательный идентификатор пакета в потоке (размер типа можеть меняться с увеличением абсолютного значения)
    * `mac(TB)`: message authentication code (HMAC SHA1) по полю data
    * `data`: данные поточного пакета, структура заголовка `STR_HEAD`, `STR_RESP`, `STR_END`, или данные (TB)
* `RESP`    extends `BASE`  подтверждение приема (ответ на одиночное сообщение, его идентификатор должен быть равен идентификатору исходного сообщения)
    * `code(T01)`: `OK = 1`, `ERROR = 2`, `NOT_AC = 3` (client not acquainted, в ответ на это клиент посылает `CLIENT_IC`), `NOT_AU = 4`  (user not acquainted, тут ничего не поделать),

### Структуры  ###

* `STR_HEAD` - заголовок потока и настройки блочного шифрования
     * `CIPHER_OPTIONS`
         * `cipher(TH)`: тип шифрования, 0-16, пока допустимы значения 0 - без шифрования, и 1 - AES
         * `keyLength(T02)`:  длина ключа
         * `mac(TH)`:     тип генератора mac, 1 - HMAC SHA1
         * `padding(TH)`: тип паддинга, 0-16, пока допустимы значения 0 - без паддинга, и 1 - PKCS5
         * `iv(TB)`:     initialization vector блочного шифра
     * `length(T??)`: беззнаковое число указывающее на размер потока, 0 подразумевает что поток ограничен только пакетом `STR_END`
* `STR_RESP`  - ответ на отправленные пакеты, отправляется на каждые N-пакетов (от 1 до 10, но не реже timeout после
     которого сетевые NAT-устроства могут посчитать udp обмен заврешенным, этот таймаут нужно определять экспериментально),
     содержит идентификаторы принятых пакетов, отправляющая сторона удаляет из буфера все `accepted` пакеты и повторно пересылает `needed`,
     если ранее отправленный пакет отсутствует в `needed` поле из `STR_RESP`, а идущие за ним пакеты уже помечены как принятые то он
     также удаляется из буфера, желательно с записью в лог ПО (т.к. это похоже на ошибку в ПО на принимающей стороне).

     Если один из пакетов был повторно запрошен **более трех** раз то выбрасывается ошибка о проблеме соединения и работа завершается.

     Если после отправки N пактов `STR_RESP` не был получен то то выбрасывается ошибка о проблеме соединения и работа завершается.

     * `accepted(TL(N))`: список принятых пакетов
     * `needed(TL(N))`: список пакетов которые нужно переслать повторно
* `STR_END` по сути структура маркер, должна отправляться в конце потока отправляющей стороной, также может быть послана
    принимающей стороной для прекращения передачи потока
* `CLIENT_ADDR`   публикация адреса клиента на сервере (имеет смысл после публикации CIC) (подписан UPrK)
    * `addrs(TL(N))`: не типизированный список пар ключ - значение, где ключ - типа адреса, значение - адрес
                      известные типы адресов: `IPV4 = (TH)1`, `IPV4 = (TH)2`, т.е. базовые типы адресов хранятся в виде цифр в половинном значении (TH)
                      для произвольных типов стоит выбирать значение типа `TB` и сохранять в нем ASCII обозначение (напр. `tor` или `bluetooth`)
* `CLIENT_IC`  публикация CIC на сервере и отправка CPubK другому client (подписан UPrK)
    * `data(TB)`: CLIENT_SIGNED
        * `user(T16)`: user id
        * `key(TB)`: CPubK
    * `sign(TB)`: подпись UPrK вычисляется по полю data
* `USER_IC`  пользовательская IC
    * `data(TB)`
        * `key(TB)`: UPubK
        * `clients(TL(T16))`: список client id этого пользоватлея (при передаче через qr-code может быть пуст, для уменьшения размера)
    * `sign(TB)`: подпись UPrK вычисляется по полю data
* `ACQUAINTED_USERS`: список известных пользователю пользователей
    * `data(TB)`
        * `users(TL(T16))`: список идентификаторов известных пользователей
    * `sign(TB)`: подпись UPrK вычисляется по полю data
* `DATA`  отправка данных клиенту  - сообщение содержит набор аттрибутов каждый состоит из идентификатора, типа и данных
    в зависимости от типа аттрибут может содержать mime-тип, размер, идентификатор потока, при большом размере
    эта структура может передаваться в потоке
    * `handler(TB)`: идентификатор обработчика (символы из набора \[a-z0-9_-\]), предопределены идентификаторы обработчиков:
        * `save`  - сохраняет данные в настроенный каталог, необходим аттрибут filename
        * `chat` - помещает сообщение во встроенный чат (пока предположим что если эо не текст то отображается кнопка действий и миниатюра куска данных)
        * `show` - отображает данные (практически тоже что и чат, только без истории и сопуствующих аттриубтов)
    * `attrs(TL)`: key-value список, предопределенные ключи имеют тип uint8 (T01), остальные в string (TB). Список
    предопределенных ключей (нумерация начинается с 1): `mime`, `filename`, `encoding` (кодировка для текста, по умолчанию полагается UTF-8)
    * `data(TB)`: собственно данные

    *дополнительные обработчики например могут позволять автоматически открывать приходящие данные (очевидно, это весьма небезопасно,
    но удобно, например показать фотографию с телефона на компьютере)*
* `STR_INIT` extends `SND_BASE` отправка запроса на прередачу шифрованного потока
    * `streamId(T02)`: идентификатор потока
    * `seed(TB)`: набор случайных данных для создания секретного ключа
    * (на будущее) *`ciphers(TL)`: список структур описывающих поддерживаемые методы шифрования*

    *в ответ придет сообщение такого же типа*, с такимже `streamId`, но иным `seed`. По `seed` src и dst генерируется секретный ключ (напр. `sha1(seed1+seed2)`)

single message - сообщение помещающееся в один UPD пакет.

секция DATA в одиночных сообщениях (все `SND_*`) шифруются CPubK адресата и подписываются CPrK отправителя,
 шифрование, очевидно обеспечивает приватность, а подпись выполняет роль аутентификацинного кода.
данные потока (`STR_*`) шифруются блочным шифром, параметры шифрования (в т.ч. секретный ключ определяются на handshake этапе)
