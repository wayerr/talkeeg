## Проткол обмена ##

TODO формат сообщений свой tgbf

взаимодествие client-client и client-server делятся на две категории,
 * одиночные сообщения, посылаются в тех случах когда передаваемые данные помещаются в один пакет (возможно в несколько,
     но не больше чем требуется для настройки потока)
 * сообщения потока - цепочки сообщений в которых важна последовательность и надежность доставки, применятся для
     больших объемов данных (возможно медиапотоков)

**важно** <br/>
в протоколе могут использоваться key-value списки, это значит что в списке элемент с четным номером (включая 0) идет
ключ, а с нечетным соотв. ему значение. Иногда при указани key-value может указываться тип ключа или значения,
напр. `key(TB),value(T02)` - ключ в виде списка байт, и значение занимаюее два байта

## типы сообщений ##

структуры транспортного уровня

* `SINGLE_MESSAGE`        единичные сообщения шифрованные CPubK адресата
    * `id(T02)`:  циклический идентификатор (используется для фильтрации дублей, уникален для каждого src)
    * `scr(T16)`: отпечаток CPubK клиента отправителя
    * `dst(T16)`: отпечаток CPubK клиента адресата
    * `clientSign(TB)`: подпись СPrK отправителя требуется всегда
    * `userSign(TB)`: подпись UPrK отправителя, требуется при данных пользователя (`USER_IC`, `ACQUAINTED_USERS`)
    * `cipherType(T01)`: тип кодирования данных: `MSG_CIPHER_NONE = 0` (используется во время CA), `MSG_RSA_ECB_PKCS1PAD = 1`
    * `data(TB)`: зашифрованные CPrK данные, содержат список `COMMAND` или `COMMAND_RESULT`
* `STR`    сообщения потока с данными  (подписан CPrK) (ему не требуется src и dst)
    * `scr(T16)`: отпечаток CPubK клиента отправителя
    * `dst(T16)`: отпечаток CPubK клиента адресата
    * `streamId(T02)`: идентификатор потока
    * `id(T04)`: последовательный идентификатор пакета в потоке
    * `mac(TB)`: message authentication code (HMAC SHA1) по полю data
    * `data(TB)`: данные поточного пакета, структура заголовка `STR_HEAD`, `STR_RESP`, `STR_END`, или данные (TB)

### Структуры  ###
* `COMMAND`  команда IPC
    * `id(T04)`: уникальный идентификатор команды (напр. последовательный счетчик)
    * `action(TB)`: строка идентифицирующая обработчик которому предназначена команда
    * `args(TL)`: список аргументов обработчика
* `RESPONSE_DATA`:  ответ на команду IPC <br/> подтверждение приема команды (с соотв. кодом), отправляется в том случае
    если команда не поддерживает ответ, или ответ не может быть сформирован немедленно, или возникла ошибка
    * `status(T01)`: код результата (в зависимости от кода опредлеяется ошибка это, подтверждение приема или полноценный ответ)
    * `message`: результат

* `STR_HEAD` - заголовок потока и настройки блочного шифрования
     * `CIPHER_OPTIONS` **ключ инициализируется в STR_INIT**
         * `cipher(T01)`: тип шифрования, 0-16, пока допустимы значения 0 - без шифрования, и 1 - AES
         * `mode(T01)`:  режим блочного шифрования 0 - NONE, и 1 - CTR
         * `mac(T01)`:     тип генератора mac, 1 - HMAC SHA1
         * `padding(T01)`: тип паддинга, 0-16, пока допустимы значения 0 - без паддинга, и 1 - PKCS5
         * `iv(TB)`:     initialization vector блочного шифра
     * `length(T??)`: беззнаковое число указывающее на размер (в байтах) потока, 0 подразумевает что поток ограничен только пакетом `STR_END`
* `STR_RESP`  - ответ на отправленные пакеты, отправляется на каждые N-пакетов (от 1 до 10, но не реже timeout после
     которого сетевые NAT-устроства могут посчитать udp обмен заврешенным, этот таймаут нужно определять экспериментально),
     содержит идентификаторы принятых пакетов, отправляющая сторона удаляет из буфера все `accepted` пакеты и повторно пересылает `needed`,
     если ранее отправленный пакет отсутствует в `needed` поле из `STR_RESP`, а идущие за ним пакеты уже помечены как принятые то он
     также удаляется из буфера, желательно с записью в лог ПО (т.к. это похоже на ошибку в ПО на принимающей стороне).

     Если один из пакетов был повторно запрошен **более трех** раз то выбрасывается ошибка о проблеме соединения и работа завершается.

     Если после отправки N пакетов `STR_RESP` не был получен то то выбрасывается ошибка о проблеме соединения и работа завершается.

     * `accepted(TL(N))`: список принятых пакетов
     * `needed(TL(N))`: список пакетов которые нужно переслать повторно
* `STR_END` по сути структура маркер, должна отправляться в конце потока отправляющей стороной, также может быть послана
    принимающей стороной для прекращения передачи потока
* `CLIENT_ADDR`   публикация адреса клиента на сервере (имеет смысл после публикации CIC) (подписан СPrK)
    * `addrs(TL(N))`: не типизированный список пар ключ - значение, где ключ - типа адреса, значение - адрес
                      известные типы адресов: `IPV4 = (TH)1` - значение T04, `IPV6 = (TH)2` - значение T16, т.е. базовые типы адресов хранятся в
                      виде цифр в половинном значении (TH) для произвольных типов стоит выбирать значение типа `TB` и сохранять в нем
                      ASCII обозначение (напр. `tor` или `bluetooth`) 
* `CLIENT_IC`  публикация CIC на сервере и отправка CPubK другому client
    * `user(T16)`: user id
    * `key(TB)`: CPubK
* `USER_IC`  пользовательская IC
    * `key(TB)`: UPubK
    * `attrs(TL)`: `key(TB),value(*)` список аттрибутов пользователя, поддерживаемые ключи: `nick`, `vcard`, произвольные ключи должны
    начинаться с `x-`, все данные пользователя поддерживаемые vcard должны попадать в vcard, использование отдельных аттрибутов для этого не допускается
    * `clients(TL(T16))`: список client id этого пользоватлея (при передаче через qr-code может быть пуст, для уменьшения размера) <br/>
      **Стоит обратить внимание**, что user может себе присвоить чужой клиент, поэтому если клиент из списка в CIC указал другого
         пользователя, то этот факт надо записать
* `ACQUAINTED_USERS`: список известных пользователю пользователей
    * `users(TL(T16))`: список идентификаторов известных пользователей
* `DATA`  отправка данных клиенту  - сообщение содержит набор аттрибутов каждый состоит из идентификатора, типа и данных
    в зависимости от типа аттрибут может содержать mime-тип, размер, идентификатор потока, при большом размере
    эта структура может передаваться в потоке
    * `action(TB)`: идентификатор обработчика (символы из набора \[a-z0-9_-\]), предопределены идентификаторы обработчиков:
        * `save`  - сохраняет данные в настроенный каталог, необходим аттрибут filename
        * `chat` - помещает сообщение во встроенный чат (пока предположим что если эо не текст то отображается кнопка действий и миниатюра куска данных)
        * `show` - отображает данные (практически тоже что и чат, только без истории и сопуствующих аттриубтов)
    * `attrs(TL)`: key-value список, ключи имеют тип string (TB). Список
    предопределенных ключей : `mime`, `filename`, `encoding` (кодировка для текста, по умолчанию полагается UTF-8)
    * `data(TB)`: собственно данные

    *дополнительные обработчики например могут позволять автоматически открывать приходящие данные (очевидно, это весьма небезопасно,
    но удобно, например показать фотографию с телефона на компьютере)*
* `STR_INIT`: отправка запроса на прередачу шифрованного потока
    * `streamId(T02)`: идентификатор потока
    * `seed(TB)`: набор случайных данных для создания секретного ключа
    * (на будущее) *`ciphers(TL)`: список структур описывающих поддерживаемые методы шифрования*

    *в ответ придет сообщение такого же типа*, с такимже `streamId`, но иным `seed`. По `seed` src и dst генерируется секретный ключ (напр. `sha1(seed1+seed2)`)

single message - сообщение помещающееся в один UPD пакет.

секция DATA в одиночных сообщениях (все `SND_*`) шифруются CPubK адресата и подписываются CPrK отправителя,
 шифрование, очевидно обеспечивает приватность, а подпись выполняет роль аутентификацинного кода.
данные потока (`STR_*`) шифруются блочным шифром, параметры шифрования (в т.ч. секретный ключ определяются на handshake этапе)
