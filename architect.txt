Проект takeeg

Архитектура

Термины

* user - пользователь, может владеть несколькими client, но также несколько client могут принадлежать одному user (предположим что пользователь обладает master ключем, это облегчает обмен ключами между стройствами, т.к. клиент просто подписывает все публичные ключи своих устройств)
* user public key (UPubK) - ключ для проверки подписи
* user private Key (UPrK) 
* user identity card (UIC) - публичный ключ клиента, и его идентификационная информация
* client - экземпляр ПО на устройстве пользователя выполняющий роль клиента
* server - экземпляр ПО на устройстве имеющем бОльший аптайм и выполняющий роль "посредника" между клиентами
* client private key (CPrK) - приватный ключ клиента (в случае сниженной безопасности может быть эквивалентен)
* client public key (CPubK)- публичный ключ клиента
* client identity card (СIC) - публичный ключ и совокупность информации о клиенте подписанное его приватным ключем (ЭЦП)
* acquainted client (AC) - клиент identity card которого сохранена на текущем клиенте
* clients acquaintance (CA) - процесс обмена клиентов их identity card
* transport - способ коммуникации client-client и client-server, по умолчанию поддерживается udp (возможно rudp) транспорт поддерживающий ipv4/ipv6 адреса (возможно будет полезно иметь транспорт через bluetooth, анонимных децентрализованных сетей и т.п.)

Требования

* публикация на server UIC
* публикация на server информации о всех устройствах текущего user
* публикация на server информации о всех адресах текущего client (локальные и внешние ipv4, ipv6, доменное имя, возможно адреса bluetooth и анонимных децентрализованных сетей)
* сохранение на server списка acquainted client (не acquainted client не может получить информацию о адресах клиента)
* user выбирает root client на котором хранится UPrK и выполняет CA для каждого устроства (все клиенты к ), затем выдает сертификаты для каждого client
* clients acquaintance: достоверная передача identity card с одного client на другой не допуская возможных MitM атак 
** по NFC
** упаковка identity card в qr-code (надо определить размер, возможно поместится только списко адресов и отпечаток публичного ключа)
** вручную (через файл или e-mail) c обязательной возможностью проверить client public key fingeprint
** через поиск на сервере по неким критериям (так же с проверкой fingeprint)
** между устроствами одного пользователя, автоматически через одну локальную сеть, qr-code, BT, или server, ключи _должны_ быть подписаны пользователем
* передача произвольных сообщений (в т.ч. произвольного размера) между различными client через шифрованное соединение
* получение с сервера событий (напр. факт обновления адреса AC)
* заложить возможность 
** передачи сообщений через server (не дешифруя трафик, но исключая потенциальные атаки с использованием сервера)
** конференций - передачи сообщени одновременно между несколькими client, желательно исключая сервер
* хранение списка acquainted client на client
* аутентификация на server по своему ключу
* отправка сообщений всем устройствам пользователя
* позже
** гибкая настройка действий на приходящие сообщения (в зависимости от групп в которые входит источник сообщения, его адреса и т.п.)
** опциональное шифрование данных хранящихся на client

Действия

client 
- при запуске
  - проверяет наличие приватного ключа в формате PKCS12
    - если его нет, то предоставялет пользователю возможность создать такой или загрузить в хранилище программы существующий
  - запрашивает пароль для приватного ключа (если требуется)
    _пароль может быть графическим или иным, надо разобраться что используется для этого на мобильниках_
    пароль можно созранять на устройстве по желанию пользователя (для андроида есть некий механизм аккаунтов стоит посмотреть что там)
  - загружает из настроек список server-ов
  - публикует на каждом server список своих адресов
- при отправке сообщения
  - выбор адресата в GUI (это список своих устройств или контактов пользователей)
  - определяет размер пакета данных
  - определяет возможность соединения // опредление подходящего транспорта и отправка, видимо, должны вполняться в самом транпорте
  - отправка
   - если размер пригоден для одного пакета то отправляет его в UDP одним пакетом (N-раз если не получено подтверждение)
   - иначе отправляет запрос на установку соединения
   - устанавливает tcp соединение
   - помещает в него данные
- при определении возможности соединения
  source client (SC) - клиент с которого будет передаваться сообщение
  destination client (DC) - клиент на который будет передаваться сообщение
  - SC определяет может ли он соединиться с известными адресами DC (в случае не удачи или если адреса нет то запрашивает с server текущий адрес DC)
    - инициируется последовательная проверка для каждого транспорта
      например для TCP\UDP
        - сначала проверяется локальный адрес
        - затем внешний
  - в случае если сообщение большое для передачи одним пакетом и DC online, но не моджет принимать входящие подключения (NAT и т.п.) 
    то определяет возможность принимать входящие подключения SC
    // полагаем что в таком случае будет иницировано обратное соединение
- при полученеии сообщения
  - если адресат - user, то сообщение рассылается остальным устройствам этого пользователя, после принятия на одном, остальным рассылается извещение о приемке - и сообщение попадает сразу в историю
  - определить устройство
  - на устройстве обработать правила (набор правил должен включать проверку что адресат устройство, т.к. адресовать устройству может только хозяйин или доверенный пользователь, и пользователь доверенный)
  - если правил нет, то известить пользователя и ждать реакции
  - после реакции пользователя разослать остальным устроствам пользователя извещение о передаче исходного сообщения в устройство

типы коротких сообщений (передаются в UDP)
TODO формат сообщений свой tgbf

* публикация адреса клиента на сервере (имеет смысл после публикации CIC)
* публикация CIC на сервере
* отправка своего публичного ключа другому клиенту (как обеспечить достоверность?) 
* отправка данных клиенту  - сообщение содержит набора аттрибутов каждый состоит из идентификатора, типа и данных
  в зависимости от типа аттрибут может содержать mime-тип, размер, идентификатор потока)
* запрос на установку с клиентом tcp соединения (имеет смысл только если работа ведется на UDP протоколе)
* запрос потока (для тех случаев когда пользователь подтвердил прием потока клиент отправляет этот запрос с идентификатором потока)
* короткое сообщение (по UDP)
* подтверждение приема (по UDP)